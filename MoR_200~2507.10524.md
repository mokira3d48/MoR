# Mixture-of-Recursions: Learning Dynamic Recursive Depths for Adaptive Token-Level Computation

**Abstract:** Scaling language models unlocks impressive capabilities, but the accompanying computational
and memory demands make both training and deployment expensive. Existing efficiency efforts typically
target either parameter sharing or adaptive computation, leaving open the question of how to attain both
simultaneously. We introduce Mixture-of-Recursions (MoR), a unified framework that combines the two axes
of efficiency inside a single Recursive Transformer. MoR reuses a shared stack of layers across recursion steps
to achieve parameter efficiency, while lightweight routers enable adaptive token-level thinking by dynamically
assigning different recursion depths to individual tokens. This allows MoR to focus quadratic attention
computation only among tokens still active at a given recursion depth, further improving memory access
efficiency by selectively caching only their key-value pairs. Beyond these core mechanisms, we also propose a KV
sharing variant that reuses KV pairs from the first recursion, specifically designed to decrease prefill latency and
memory footprint. Across model scales ranging from 135M to 1.7B parameters, MoR forms a new Pareto frontier:
at equal training FLOPs and smaller model sizes, it significantly lowers validation perplexity and improves few-
shot accuracy, while delivering higher throughput compared with vanilla and existing recursive baselines. These
gains demonstrate that MoR is an effective path towards large-model quality without incurring large-model cost.

## 1. Introduction

Scaling Transformer networks to hundreds of billions of parameters has unlocked impressive few-shot
generalization and reasoning abilities (Brown et al., 2020; Chowdhery et al., 2023; Llama Team, 2024; OpenAI,
2023; Gemini Team, 2024; DeepSeek-AI, 2024; Gemini Team, 2025). However, the accompanying memory footprint and computational requirements make both training and deployment outside hyperscale data centers
challenging (Patterson et al., 2021; Momeni et al., 2024). This has motivated researchers to seek alternative
‚Äúefficient‚Äù designs (Tay et al., 2022; Wan et al., 2023). Among the different axes of efficiency, parameter
efficiency (Dehghani et al., 2018; Bae et al., 2024; Shazeer et al., 2017; Fedus et al., 2022; LeCun et al.,
1989)‚Äîreducing or sharing model weights‚Äîand adaptive computation (Raposo et al., 2024; Schuster et al.,
2022; Fedus et al., 2022; Leviathan et al., 2023)‚Äîspending more compute only when it is needed‚Äîare
promising, actively studied research directions.

One proven route to parameter efficiency is layer tying, in which a shared set of weights is reused across
multiple layers (Dehghani et al., 2018; Lan et al., 2019; Takase and Kiyono, 2021; Gholami and Omar, 2023;
Bae et al., 2024). For adaptive computation, a common approach is early-exiting, which dynamically allocates
compute by exiting earlier in the network when predicting simpler tokens (Elhoushi et al., 2024; Schuster et al.,
2022; Elbayad et al., 2020; Bae et al., 2023). Despite the progress achieved along each of these individual
efficiency axes, an architecture that effectively unifies both parameter efficiency and adaptive computation is
still missing. Recursive Transformers (Bae et al., 2024; Fan et al., 2024; Giannou et al., 2023; Yang et al., 2023;
Saunshi et al., 2025; Geiping et al., 2025; Aleksandrov et al., 2025), models that repeatedly apply the same set
of shared layers multiple times, offer a strong foundation due to their built-in weight sharing. However, prior
attempts at dynamic recursion have often been constrained by practical hurdles, such as requiring additional
specialized training procedures or facing challenges in efficient deployment. This has led most approaches to
still default to a simpler fixed-depth recursion, which applies the same amount of computation to every token
and is thus incapable of delivering truly adaptive token-level compute allocation.

In this work, we introduce Mixture-of-Recursions (MoR), a unified framework that fully leverages the
potential of Recursive Transformers (see Figure 1). MoR trains lightweight routers end-to-end to assign
token-specific recursion depths: it decides how many times a shared parameter block is applied to each token
according to its required depth of ‚Äúthinking‚Äù, thereby directing computation to where it is most needed. This
dynamic, token-level recursion inherently facilitates recursion-wise key‚Äìvalue (KV) caching, selectively storing
and retrieving key‚Äìvalue pairs corresponding to each token‚Äôs assigned recursion depth. This targeted caching
strategy reduces memory traffic, thereby improving throughput without relying on post-hoc modifications.
Therefore, MoR simultaneously (i) ties weights to cut parameters, (ii) routes tokens to cut redundant FLOPs,
and (iii) caches key-values recursion-wise to cut memory traffic‚Äîall inside a single architecture.

Conceptually, MoR provides a pre-training framework for latent space reasoning‚Äîperforming non-verbal
thinking by iteratively applying a single parameter block (Hao et al., 2024; Geiping et al., 2025; Goyal et al.,
2023). However, unlike approaches that deliberate on augmented continuous prompts before generation (Liu
et al., 2024b; Goyal et al., 2023; Hao et al., 2024; Shen et al., 2025), MoR enables this latent thinking directly
during the decoding of each token (Zelikman et al., 2024). Furthermore, routing mechanism facilitates adaptive
reasoning along the model‚Äôs vertical axis1, moving beyond the uniform, fixed thinking depth common in prior
work (Geiping et al., 2025; Tack et al., 2025). In essence, MoR enables models to efficiently adjust their
thinking depth on a per-token basis, unifying parameter efficiency with adaptive computation.

**Contributions.** In summary, our key contributions in this paper are as follows.

- **Unified framework for efficient language modeling:** We present Mixture-of-Recursions (MoR), the first archi-
tecture to unify efficiency paradigms‚Äîparameter sharing (¬ß2.1), token-level adaptive thinking depth (¬ß2.2.1),
and memory-efficient KV caching (¬ß2.2.2)‚Äîwithin a single framework.
- **Dynamic recursion routing:** We introduce a router trained from scratch to assign dynamic per-token
recursion depths. This aligns training with inference-time behavior and eliminates the need for costly,
performance-degrading post-hoc routing stages used in conventional early-exit methods.
- **Extensive empirical validation:** Across models from 135M to 1.7B parameters2 under equal compute
budgets, MoR establishes a new Pareto frontier by improving validation loss and few-shot accuracy relative
to vanilla and recursive baselines (¬ß3.1, ¬ß3.2).
- **Efficient architecture:** MoR dramatically reduces training FLOPs by selectively engaging only essential
sequences in attention operations. Simultaneously, reduction in KV cache sizes leads to enhanced inference
throughput itself, further boosted by continuous depth-wise batching (¬ß3.3).

**Table 1:** Parameter-sharing strategies in Recursive Transformers. This table shows Cycle and Middle-Cycle schemes with
cyclic layer reuse, where Middle-Cycle retains unique first and last layers.

| Layers | Cycle Strategy | | Middle-Cycle Strategy | |
| :--- | :--- | :--- | :--- | :--- |
| | **Equation** | **Figure** | **Equation** | **Figure** |
| Last | - | | $f(\mathbf{h}_{t}^{L-1}; \Phi_{L-1})$ | !(https://i.imgur.com/your-image-url-for-layer-3.png) |
| Recursion | $f(\mathbf{h}_{t}^{\ell}; \Phi_{\ell \bmod (L/N_{r})})$ | !(https://i.imgur.com/your-image-url-for-recursion.png) | $f(\mathbf{h}_{t}^{\ell}; \Phi_{(\ell-1 \bmod ((L-2)/N_{r}))+1})$ | !(https://i.imgur.com/your-image-url-for-recursion-middle.png) |
| First | - | | $f(\mathbf{h}_{t}^{0}; \Phi_{0})$ | !(https://i.imgur.com/your-image-url-for-layer-0.png) |


## 2. Method

### 2.1. Preliminary

**Recursive Transformers.** The standard Transformer (Vaswani et al., 2017) constructs token representations
through a stack of ùêø unique layers, each with a self-attention and a feed-forward network. At time step $t$, the hidden state $h$ evolves as: $h_{t}^{l + 1} = f(h_{t}^{l}, \Phi_{l})$, 
where $l = 0, \ldots, L - 1$ and $\Phi_l$ represents the parameters of the $l$-th layer.
Recursive Transformers (Bae et al., 2024; Fan et al., 2024; Giannou et al., 2023; Yang et al.,
2023; Saunshi et al., 2025) aim to reduce parameter count by reusing layers across depth. Instead of having $L$ distinct sets of weights, they partition the model into $N_r$
recursion blocks, where each block uses a shared pool of parameters $\Phi'$. 
This design allows for more computation (by increasing the effective network depth)
without increasing parameter size.

**Parameter-sharing strategies.** We examine four parameter-sharing strategies: Cycle, 
Sequence, and their variants Middle-Cycle and Middle-Sequence.
**Table 1** summarizes two main designs, and the full list is provided in
**Table 5** in the Appendix.  In Cycle sharing, recursion blocks are reused cyclically. For 
example, consider an original non-recursive model with $L = 9$ layers and its recursive 
counterpart using $N_r = 3$ recursions. Under the ‚ÄúCycle‚Äù strategy, the layers are shared 
and unrolled as ` [(0, 1, 2), (0, 1, 2), (0, 1, 2)]`.  In ‚ÄúSequence‚Äù sharing, each recursion
block reuses the same layer consecutively before moving to the next,
resulting in  `[(0, 0, 0), (1, 1, 1), (2, 2, 2)]` for the same configuration.
Both have the same effective number of layers when unrolled ($L = 9$), 
but with a different order. Furthermore, the ‚ÄúMiddle‚Äù variants preserve full-capacity 
parameters at the first and last layers ($\Phi_0$ and $\Phi_{L - 1}$),
while sharing weights among the intermediate layers.

**Enhanced training and inference efficiency in recursive models.** Parameter sharing strategies can reduce
the number of unique trainable parameters by a factor of the recursion number, effectively amortizing the
memory footprint of the model. From a distributed training perspective, this becomes highly efficient when
using Fully Sharded Data Parallel (FSDP) (Zhao et al., 2023). While a single `all-gather ` 
operation would only
support one iteration previously (i.e., 1 iter/gather), a recursive model reuses the same gathered parameters
across all recursive steps (i.e., $N_r$ iter/gather). 
Furthermore, recursive architectures enable a novel inference
paradigm, continuous depth-wise batching (Bae et al., 2024; Hooper et al., 2023). This technique allows tokens
at different stages to be grouped into a single batch, as they all utilize the same block of parameters. This can
eliminate the bubbles‚Äîidle periods spent waiting for other samples to complete‚Äîthereby leading to significant
throughput gains.

**Limitations in prior works.** Although model parameters are tied, the distinct KV caches are typically used
for each depth. This design fails to reduce the cache sizes, meaning the high retrieval latency still remains a
severe inference bottleneck. Moreover, most existing recursive models simply apply a fixed recursion depth to
all tokens, ignoring the varying complexity. While post-hoc methods like early-exiting methods can introduce
some adaptivity, they often require separate training phases that can degrade performance (Schuster et al.,
2022; Elhoushi et al., 2024; Bae et al., 2024). Ideally, the recursion depth should be learned dynamically during
pretraining, allowing the model to adapt its computational path to each token‚Äôs difficulty in a data-driven
manner. However, such dynamic paths introduce a new challenge: exited tokens will have missing KV pairs at
subsequent recursion depths. Addressing this would require a parallel decoding mechanism (Bae et al., 2023;
Elhoushi et al., 2024; Kim et al., 2023b) to efficiently compute the actual KV pairs, but this requires separate,
complex engineering and complicates the system.

![]()

**Figure 2:** Architectural components of Mixture-of-Recursions (MoR). (a) Expert-choice routing: At each recursion step,
a router selects top-ùëò tokens to continue, progressively narrowing the set of active tokens with depth. (b) Token-choice
routing: Each token is assigned a fixed recursion step at the outset via a single routing decision, defining its complete
compute path through the model. (c) KV caching strategies: Each square in the matrix represents whether a token (row)
attends to another token‚Äôs cached key (column). In ‚Äúrecursion-wise KV caching‚Äù (Top), only the keys of currently selected
(non-dropped) tokens at each recursion step are cached ( blue ), and attention is restricted only to these entries. In
‚Äúrecursive KV sharing‚Äù (Bottom), all keys of previous tokens are cached at the first recursion step ( purple ) and shared
across subsequent recursion steps for attention operations.

## 2.2. Mixture-of-Recursions
We propose Mixture-of-Recursions (MoR)‚Äîa framework that dynamically adjusts recursion step for each token
during pretraining and inference. The core of MoR lies in two components: a routing mechanism that assigns
token-specific recursion steps to adaptively concentrate computation on more challenging tokens, and a KV
caching strategy that defines how KV pairs are stored and selectively utilized for attention at each recursive step.


### 2.2.1. Routing Strategies: Expert-choice vs. Token-choice

**Expert-choice routing. (Figure 2a)** Inspired by top-ùëò gating in MoD models (Raposo et al., 2024), in expert-
choice routing, each recursion depth becomes an expert and selects their preferred top-$ùëò$ tokens (e.g., for $N_r = 3$ we have three experts: Expert 1 applies the first recursion step, Expert 2 applies the second recursion step, and
so on) . At each recursion step $r$, the corresponding router uses the hidden state
$\mathcal{H}_{t}^{r}$ (input to the $r$-th recursion
block) and its routing parameters $\theta_r$ to compute a scalar score 
$ g_{t}^{r} = \mathcal{G}(\theta_{t}^{T} \mathcal{H}_{t}^{r})$ for token $t$. Here, $\mathcal{G}$
represents an
activation function like `sigmoid` or `tanh`. Then, the top-$ùëò$ tokens are selected to pass through the recursion block: 

$$
\mathcal{H}_{t}^{r+1} =
\begin{cases}
g_{t}^{r} f(\mathcal{H}_{t}^{r}, \Phi') + \mathcal{H}_{t}^{r}, & \text{if } g_{t}^{r} > P_{\beta}(G^{r}) \\
\mathcal{H}_{t}^{r}, & \text{otherwise}
\end{cases}
$$

where $P_{\beta}(G^{r})$ is the $\beta$-percentile threshold over all scores at recursion step $r$.

To ensure coherent progression through steps, we adopt hierarchical filtering: only tokens selected at
recursion step $r$  can be re-evaluated at $r + 1$ This simulates early-exit behavior while learning from scratch. As
deeper layers tend to encode increasingly abstract and sparse information (Li et al., 2022; Yang et al., 2024;
Nawrot et al., 2024), this mechanism prioritizes computation for only the most demanding tokens.

**Token-choice routing. (Figure 2b)** Unlike expert-choice, where token selection is made at each recursion
step, token-choice commits each token to a full sequence of recursion blocks from the start. Formally, given
the hidden state $\mathcal{H}_{t}^{1}$ (in Middle-Cycle strategy, $\mathcal{H}_{t}^{1} = h_{t}^{1}$), the router computes a non-linear function (`softmax` or `sigmoid`) over experts:
$g_t = \mathcal{G}(\theta_{r}^{T} \mathcal{H}_{t}^{1})$, where $g_{t}^{j}$ denotes
 the routing score for expert $j \in \{1, \ldots, N_r\}$. The
token is assigned to expert $i = \arg \max_{j} g_{t}^{j}$ (top-1 gating), which corresponds 
to sequentially applying the recursion $i$ times. The hidden state is then updated recursively as:

$$
\mathcal{H}_{t}^{r+1} =
\begin{cases}
g_{t}^{r}f(\mathcal{H}_{t}^{r}, \Phi') + \mathcal{H}_{t}^{1}, & \text{if } r = i \\
g_{t}^{r}f(\mathcal{H}_{t}^{r}, \Phi'), & \text{otherwise}
\end{cases}
$$


**Table 2:** Comparison of routing strategies and key-value caching strategies. (Left) Summary of two routing strategies:
expert-choice and token-choice, highlighting their pros, cons, and mitigating solutions from previous works (Raposo et al.,
2024; Wang et al., 2024; Zoph et al., 2022). (Right) Relative cost efficiency of caching strategies against a vanilla Transformer
(normalized to 1). Here, $N_r$ denotes the number of recursions, and $k$ ($k < N_{ctx}$) 
denotes the number of selected tokens
per layer. KV cache memory and IO are measured across the entire model, whereas attention FLOPs are reported per layer.


| | **Expert-choice** | **Token-choice** | | **Recursion-wise Caching** | **Recursive Sharing** |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **Pros** | Static compute budget | No leakage | **KV Memory** | $(N_r + 1)/2N_r$ | $1/N_r$ |
| **Cons** | Causality violation | Load imbalance | **KV Cache IO** | $(N_r + 1)/2N_r$ | 1 |
| **Sol.** | Aux Rout, Aux Loss | Bal Loss, Loss-free | **Attn FLOPs** | $k^2 / N_{ctx}$ | $k/N_{ctx}$ |

To compare routing strategies under equal compute, we align the token allocation budgets of expert-choice
with that of token-choice. Specifically, we calibrate token capacity (i.e., top-$k$) of expert-choice to match
the expected token distribution of token-choice routing with perfect load balancing. In perfectly balanced
token-choice, each token is assigned to recursion depth $i \in \{1, \ldots, N_r\}
with equal probability $1/N_r$. Thus, recursion step $j$ processes a fraction
$(N_r - j + 1)/N_r$ of the tokens. For example, when $N_r = 3$, 
recursion steps $1$, $2$, and $3$ handle $\{3/3, 2/3, 1/3\}$ of tokens, respectively. Therefore, we apply this same fractional allocation in the top-$ùëò$ selection
of the expert-choice routing (i.e., $k$ is sequenced like $N_r/N_r, \ldots, 1/N_r$
over $N_r$ recursion steps).
